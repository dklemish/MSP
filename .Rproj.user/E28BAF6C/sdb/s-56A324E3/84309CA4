{
    "collab_server" : "",
    "contents" : "#include <R.h>\n#include <Rmath.h>\n#include <RcppArmadillo.h>\n#include <string>\n#include <cmath>\n\n// #define PI 3.141592653589793238462643383279502884197169399\n\n// RcppArmadillo.h also includes Rcpp.h\n\n// Declare dependency on RcppArmadillo so Rcpp knows to link libraries\n// [[Rcpp::depends(RcppArmadillo)]]\n\nusing namespace Rcpp;\nusing namespace arma;\n\n/***** Function headers *****/\nvoid rmvnorm(vec&, mat &, vec &, int);\nvoid rgev(const double &, const int &, vec &);\nvoid rpstable(const double &, const int &, vec &);\nvoid calcDistance(mat &, mat &, int);\nvoid storeCalc(mat &, vec &, vec &, double &, int &, int &, int &);\n\nvoid covMatern(int, mat &, double, double, double, mat &);\nvoid covPowExp(int, mat &, double, double, double, mat &);\n\nvoid mspBrownResnick(bool, int, int &, int &, double, vec &, const vec &, const mat &, mat &, vec &);\nvoid mspExtremeT(bool, int, int &, int &, double cstar, vec &, const vec &, const mat &, const double, mat &, vec &);\n\n// [[Rcpp::export]]\nSEXP Sim_SP(\n    SEXP x_, \n    SEXP cstar_,\n    SEXP model_,\n    SEXP corrFn_,\n    SEXP keepPsi_,\n    SEXP covPar_, \n    SEXP alpha_){\n  /***** Initialization *****/\n  // Variable declarations\n  bool keepPsi;\n  int n;                // Total # of grid points (n in 1D, n^2 in 2D)\n  int d;                // # of dimensions\n  int count = 0;\n  int curr_storage = 100;\n  double cstar;         // Approx max value of stochastic process\n  double sigma2;        // Partial sill\n  double phi;           // 1 / range covariance parameter\n  double nu;            // Matern parameter\n  double gamma;         // Exponential covariance parameter\n  double alpha;         // Extreme T process parameter\n  std::string corrFn;\n  std::string model;\n  mat x;                // Location matrix\n  mat Sigma;            // Covariance matrix of underlying process\n  mat distMat;          // Matrix of pairwise distances between spatial locations\n  mat psiStore;         // Matrix to store psi functions\n  vec Z;                // Output\n  vec zero_mean;        // Zero vector, size n\n  vec zetaStore;        // Matrix to store zeta values\n  List covPar;          // List of covariance function parameters\n  \n  // Convert SEXP objects to Rcpp objects\n  NumericMatrix X = as<NumericMatrix>(x_);\n  cstar = as<double>(cstar_);\n  corrFn = as<std::string>(corrFn_);\n  model = as<std::string>(model_);\n  keepPsi = as<bool>(keepPsi_);\n  covPar = as<List>(covPar_);\n  alpha = as<double>(alpha_);\n  \n  // Initialize other variables\n  x   = mat(X.begin(), X.nrow(), X.ncol(), TRUE);\n  n   = X.nrow();\n  d   = X.ncol();\n  \n  sigma2 = as<double>(covPar[0]);\n  phi    = as<double>(covPar[1]);\n  nu     = as<double>(covPar[2]);\n  gamma  = as<double>(covPar[3]);\n  \n  Sigma   = mat(n, n);\n  distMat = mat(n, n);\n  \n  zero_mean = vec(n, fill::zeros);\n  \n  // Allocate output storage\n  Z = vec(n, fill::zeros);\n  psiStore = mat(curr_storage, n);\n  zetaStore = vec(curr_storage);\n  \n  /**** Calculations ****/\n  /* Calculate distance matrix between all points */\n  calcDistance(x, distMat, n);\n  \n  if(corrFn == \"Matern\"){\n    covMatern(n, distMat, sigma2, phi, nu, Sigma);\n  } else if(corrFn == \"Exp\"){\n    covPowExp(n, distMat, sigma2, phi, 1.0, Sigma);\n  } else if(corrFn == \"PowExp\"){\n    covPowExp(n, distMat, sigma2, phi, gamma, Sigma);\n  }\n  GetRNGstate();\n  \n  if(model==\"Brown-Resnick\"){\n    mspBrownResnick(keepPsi, n, count, curr_storage, cstar, Z, zero_mean, Sigma, psiStore, zetaStore);\n  } else if(model==\"extremeGauss\"){\n    mspExtremeT(keepPsi, n, count, curr_storage, cstar, Z, zero_mean, Sigma, 1.0, psiStore, zetaStore);\n  } else if(model==\"extremeT\"){\n    mspExtremeT(keepPsi, n, count, curr_storage, cstar, Z, zero_mean, Sigma, alpha, psiStore, zetaStore);\n  }\n  \n  if(keepPsi){\n    mat psiOut(psiStore.rows(0, count-1));\n    vec zetaOut(zetaStore.subvec(0, count-1));\n    \n    return Rcpp::List::create(\n      Rcpp::Named(\"dim\") = d,\n      Rcpp::Named(\"num_functions\") = count-1,\n      Rcpp::Named(\"X\") = x,\n      Rcpp::Named(\"Z\") = Z,\n      Rcpp::Named(\"psi\") = psiOut,\n      Rcpp::Named(\"zeta\") = zetaOut);\n  }else{\n    return Rcpp::List::create(\n      Rcpp::Named(\"dim\") = d,\n      Rcpp::Named(\"num_functions\") = count-1,\n      Rcpp::Named(\"X\") = x,\n      Rcpp::Named(\"Z\") = Z);\n  }\n}\n\n// [[Rcpp::export]]\nSEXP Sim_Reich(\n    SEXP x_, \n    SEXP knots_,\n    SEXP Sigma_, \n    SEXP keepPsi_,\n    SEXP bw_,\n    SEXP alpha_){\n  /***** Initialization *****/\n  // Variable declarations\n  bool keepPsi;\n  int n;                // Total # of grid points (n in 1D, n^2 in 2D)\n  int nknots;           // Total # of knot points\n  int d;                // # of dimensions\n  double bw;\n  double alpha;         // \n  double temp;\n  \n  mat x;                // Location matrix\n  mat knots;            // Knot locations\n  mat Sigma;            // Covariance matrix of underlying process\n  mat kernelVal;        // Matrix to store kernel values at each grid point\n  vec A;                // Vector to store A values\n  vec U;                // Vector to store U values\n  vec theta;            // Vector to store theta values\n  vec Z;                // Output\n  \n  // Convert SEXP objects to Rcpp objects\n  NumericMatrix X = as<NumericMatrix>(x_);\n  NumericMatrix knotsR = as<NumericMatrix>(knots_);\n  NumericMatrix SigmaR = as<NumericMatrix>(Sigma_);\n  \n  keepPsi = as<bool>(keepPsi_);\n  bw      = as<double>(bw_);\n  alpha   = as<double>(alpha_);\n  \n  // Initialize other variables\n  x     = mat(X.begin(), X.nrow(), X.ncol(), TRUE);\n  knots = mat(knotsR.begin(), knotsR.nrow(), knotsR.ncol(), TRUE);\n  Sigma = mat(SigmaR.begin(), SigmaR.nrow(), SigmaR.ncol(), TRUE);\n  n   = X.nrow();\n  d   = X.ncol();\n  nknots = knotsR.nrow();\n  kernelVal = mat(n, nknots);\n  \n  // Allocate output storage\n  Z = vec(n, fill::zeros);\n  A = vec(nknots);\n  U = vec(n);\n  theta = vec(n);\n  \n  /**** Calculations ****/\n  // Calculate kernel values at each grid point\n  \n  const double normConst1 = 1/(2*PI*bw);\n  const double normConst2 = 1/(2*bw);\n  vec kernelSum = vec(n);\n  \n  for(int i=0; i<n; i++){\n    for(int j=0; j<nknots; j++){\n      kernelVal.at(i,j) = normConst1 * exp(-normConst2 * as_scalar((x.row(i) - knots.row(j)) * Sigma * (x.row(i) - knots.row(j)).t()));\n    }\n    kernelSum.at(i) = sum(kernelVal.row(i));\n  }\n\n  for(int i=0; i<n; i++){\n    for(int j=0; j<nknots; j++){\n      kernelVal.at(i,j) = kernelVal.at(i,j) / kernelSum.at(i);\n    }\n  }\n  \n  // Simulations \n  GetRNGstate();\n  \n  rpstable(alpha, nknots, A); // Simulate values for A/theta (basis function coefficients)\n  rgev(alpha, n, U);          // Simulate values for U (nugget effect)\n  \n  for(int i = 0; i<n; i++){\n    temp = 0;\n    for(int j = 0; j<nknots; j++){\n      //Rcout << A.at(j) << \" \" << pow(kernelVal.at(i,j), 1/alpha) << std::endl;\n      temp += A.at(j) * pow(kernelVal.at(i,j), 1/alpha);\n    }\n    theta.at(i) = pow(temp, alpha);\n  }\n  \n  Z = U % theta;\n  \n  if(keepPsi){\n    return Rcpp::List::create(\n      Rcpp::Named(\"dim\") = d,\n      Rcpp::Named(\"X\") = x,\n      Rcpp::Named(\"Z\") = Z,\n      Rcpp::Named(\"A\") = A,\n      Rcpp::Named(\"U\") = U,\n      Rcpp::Named(\"theta\") = theta,\n      Rcpp::Named(\"kernel\") = kernelVal);\n  }else{\n    return Rcpp::List::create(\n      Rcpp::Named(\"dim\") = d,\n      Rcpp::Named(\"X\") = x,\n      Rcpp::Named(\"Z\") = Z);\n  }\n}\n\nvoid rmvnorm(const vec &mu, const mat &Sigma, vec &result, int d){\n  mat L = arma::chol(Sigma, \"lower\");\n  \n  vec draw = vec(d);\n  for(int i=0; i < d; i++){\n    draw.at(i) = R::rnorm(0, 1);\n  }\n  \n  result = mu + L * draw;\n  \n  return;\n}\n\nvoid rgev(const double &alpha, const int &n, vec & result){\n  // Simulate from a GEV(1, alpha, alpha) distribution\n  double u;\n  \n  for(int i=0; i < n; i++){\n    u = R::runif(0, 1);\n    result.at(i) = pow(-log(u),-alpha);\n  }\n  \n  return;\n  \n}\n\nvoid rpstable(const double &alpha, const int &nknots, vec &result){\n  // Chambers/Mallow/Stuck algorithm for simulating from stable(alpha, beta=1, mu=0, c=1)\n  // Parameterization with beta=1, mu=0, alpha < 1 restricts support to [0, Inf)\n  double u, w;\n  const double zeta = -tan(PI*alpha/2);\n  const double xi   = PI/2;\n  const double z1   = pow(1+zeta*zeta, 1/(2*alpha));\n  double z2, z3, z4;\n\n  for(int i=0; i < nknots; i++){\n    u = R::runif(-PI/2, PI/2);\n    w = R::rexp(1.0);\n\n    z2 = sin(alpha*(u+xi));\n    z3 = pow(cos(u), 1/alpha);\n    z4 = cos(u-alpha*(u+xi))/w;\n    \n    //result.at(i) = z1 * (z2 / z3) * pow(z4, (1-alpha)/alpha);\n    result.at(i) = (z2 / z3) * pow(z4, (1-alpha)/alpha);\n  }\n  \n  return;\n}\n\nvoid calcDistance(mat &x, mat &dist, int n){\n  for(int i = 0; i < n; i++){\n    for(int j = i; j < n; j++){\n      dist(i,j) = norm(x.row(i) - x.row(j));\n    }\n  }\n  dist = symmatu(dist);\n  \n  return;\n}\n\nvoid covMatern(int n, mat &distMat, double sigma2, double phi, double nu, mat &Sigma){\n  double temp = sigma2 / (pow(2, nu-1) * R::gammafn(nu));\n  \n  for(int i = 0; i < n; i++){\n    Sigma.at(i,i) = sigma2;\n    for(int j = i+1; j < n; j++){\n      Sigma.at(i,j) = temp * pow(phi*distMat.at(i,j), nu) * R::bessel_k(phi*distMat.at(i,j), nu, 1);\n    }\n  }\n  \n  Sigma = symmatu(Sigma);\n  \n  return;\n}\n\nvoid covPowExp(int n, mat &distMat, double sigma2, double phi, double gamma, mat &Sigma){\n  for(int i = 0; i < n; i++){\n    Sigma.at(i,i) = sigma2;\n    for(int j = i+1; j < n; j++){\n      Sigma.at(i,j) = sigma2 * exp(-1 * pow(phi*distMat.at(i,j), gamma));\n    }\n  }\n  \n  Sigma = symmatu(Sigma);\n  \n  return;\n}\n\nvoid mspBrownResnick(bool keepPsi, int n, int &count, int &curr_storage, double cstar, \n                     vec &Z, const vec &zero, const mat &Sigma,\n                     mat &psiStore, vec &zetaStore){\n  double minZ = 0;\n  double zetaInv = R::rexp(1);\n  vec psi = vec(n);\n  vec tempVec = vec(n);\n  \n  while(cstar/zetaInv > minZ){\n    rmvnorm(zero, Sigma, tempVec, n);\n    psi = exp(tempVec - Sigma.diag(0)/2.0);\n    Z = max(Z, psi / zetaInv);\n    \n    zetaInv += R::rexp(1);\n    minZ = min(Z);\n    \n    if(keepPsi){\n      storeCalc(psiStore, zetaStore, psi, zetaInv, n, count, curr_storage);\n    }\n  }\n  return; \n}\n\nvoid mspExtremeT(bool keepPsi, int n, int &count, int &curr_storage, double cstar, \n                 vec &Z, const vec &zero, const mat &Sigma, const double alpha, \n                 mat &psiStore, vec &zetaStore){\n  double minZ = 0;\n  double zetaInv = R::rexp(1);\n  double norm_constant = sqrt(PI) * pow(2, -(alpha-2)/2) / tgamma((alpha+1)/2);\n  \n  vec psi = vec(n);\n  vec tempVec = vec(n);\n  \n  while(cstar/zetaInv > minZ){\n    rmvnorm(zero, Sigma, tempVec, n);\n    psi = pow(max(tempVec, zero), alpha);\n    Z = max(Z, norm_constant * psi / zetaInv);\n    \n    zetaInv += R::rexp(1);\n    minZ = min(Z);\n    \n    if(keepPsi){\n      storeCalc(psiStore, zetaStore, psi, zetaInv, n, count, curr_storage);\n    }\n  }\n  return; \n}\n\nvoid storeCalc(mat &psiStore, vec &zetaStore, vec &psi, double &zetaInv, int &n, int &count, int &curr_storage){\n  psiStore.row(count) = psi.t();\n  zetaStore.at(count) = 1/zetaInv;\n  count++;\n  \n  if(count == curr_storage){\n    psiStore.resize(2*curr_storage, n);\n    zetaStore.resize(2*curr_storage);\n    curr_storage = 2*curr_storage;\n  }\n}",
    "created" : 1508730244406.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3012791376",
    "id" : "84309CA4",
    "lastKnownWriteTime" : 1508731019,
    "last_content_update" : 1508731019533,
    "path" : "~/MaxStable/MSP/src/rcpp_hello_world.cpp",
    "project_path" : "src/rcpp_hello_world.cpp",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}